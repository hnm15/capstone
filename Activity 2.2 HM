{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## DX799S O1 Data Science Capstone (Summer 1 2025): ACTIVITY 2.2 ##"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each week, you will apply the concepts of that week to your Integrated Capstone Projectâ€™s dataset. In preparation for Milestone One, create a Jupyter Notebook (similar to in Module B, semester two) that illustrates these lessons. There are no specific questions to answer in your Jupyter Notebook files in this course; your general goal is to analyze your data, using the methods you have learned about in this course and in this program, and draw interesting conclusions. \n",
    "\n",
    "For Week 2, include concepts such as linear regression with lasso, ridge, and elastic net regression. This homework will be submitted for peer review and feedback in Week 3 in the assignment titled 3.4 Peer Review: Week 2 Jupyter Notebook. Complete your Jupyter Notebook homework by 11:59 pm ET on Sunday.\n",
    "\n",
    "In Week 7, you will compile your findings from your Jupyter Notebook homework into your Milestone One assignment for grading. For full instructions and the rubric for Milestone One, refer to the following link. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ===================================\n",
    "# Useful Imports: Add more as needed\n",
    "# ===================================\n",
    "\n",
    "# Standard Libraries\n",
    "import os\n",
    "import time\n",
    "import math\n",
    "import io\n",
    "import zipfile\n",
    "import requests\n",
    "from urllib.parse import urlparse\n",
    "from itertools import chain, combinations\n",
    "\n",
    "# Data Science Libraries\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "\n",
    "# Visualization\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.patches as patches\n",
    "import matplotlib.ticker as mticker  # Optional: Format y-axis labels as dollars\n",
    "import seaborn as sns\n",
    "\n",
    "# Scikit-learn (Machine Learning)\n",
    "from sklearn.model_selection import (\n",
    "    train_test_split, \n",
    "    cross_val_score, \n",
    "    GridSearchCV, \n",
    "    RandomizedSearchCV, \n",
    "    RepeatedKFold\n",
    ")\n",
    "from sklearn.preprocessing import StandardScaler, OrdinalEncoder\n",
    "from sklearn.impute import SimpleImputer\n",
    "from sklearn.metrics import mean_squared_error\n",
    "from sklearn.feature_selection import SequentialFeatureSelector, f_regression, SelectKBest\n",
    "from sklearn.linear_model import LinearRegression, Ridge, Lasso, ElasticNet\n",
    "\n",
    "import pandas as pd\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import StandardScaler, LabelEncoder\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {},
   "outputs": [],
   "source": [
    "repeated_cv = RepeatedKFold(n_splits=5, n_repeats=5, random_state=42)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Object columns before encoding:\n",
      "Index(['Player_Activity_Derived', 'Turnover_Related', 'Primary_Impact_Type',\n",
      "       'Primary_Partner_GSISID', 'Primary_Partner_Activity_Derived',\n",
      "       'Friendly_Fire'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "#Video Review Dataset \n",
    "\n",
    "df_videoreview = pd.read_csv(\"video_review.csv\")\n",
    "\n",
    "label_encoder = LabelEncoder()\n",
    "\n",
    "print(\"Object columns before encoding:\")\n",
    "print(df_videoreview.select_dtypes(include=['object']).columns)\n",
    "\n",
    "for col in df_videoreview.select_dtypes(include=['object']).columns:\n",
    "    df_videoreview[col] = label_encoder.fit_transform(df_videoreview[col].astype(str))\n",
    "\n",
    "\n",
    "target_column = 'Primary_Impact_Type'  \n",
    "X = df_videoreview.drop(columns=[target_column])\n",
    "y = df_videoreview[target_column]\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "\n",
    "scaler = StandardScaler()\n",
    "X_train_scaled = scaler.fit_transform(X_train)\n",
    "X_test_scaled = scaler.transform(X_test)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Lasso Regression on Video Review Dataset: 1.07\n",
      "Standard Deviation CV RMSE for Lasso Regression on Video Review Dataset: 0.11\n"
     ]
    }
   ],
   "source": [
    "# Video Review with Lasso Regression using Primary_Impact_Type as Target\n",
    "\n",
    "lasso = Lasso(alpha=1.0, max_iter=10000)\n",
    "\n",
    "neg_mse_scores = cross_val_score(lasso, X_train_scaled, y_train, cv=repeated_cv, scoring='neg_mean_squared_error')\n",
    "mse_scores = -neg_mse_scores\n",
    "\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Lasso Regression on Video Review Dataset: {mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE for Lasso Regression on Video Review Dataset: {std_rmse:,.2f}')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Ridge Regression on Video Review Dataset: $1.25\n",
      "Standard Deviation CV RMSE for Ridge Regression on Video Review Dataset: 0.30\n"
     ]
    }
   ],
   "source": [
    "# Video Review with Ridge Regression using Primary_Impact_Type as Target\n",
    "\n",
    "ridge = Ridge()\n",
    "\n",
    "neg_mse_scores = cross_val_score(ridge, X_train_scaled, y_train, cv=repeated_cv, scoring='neg_mean_squared_error')\n",
    "mse_scores = -neg_mse_scores\n",
    "\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Ridge Regression on Video Review Dataset: ${mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE for Ridge Regression on Video Review Dataset: {std_rmse:,.2f}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best alpha: 1.2915496650148828\n",
      "Best l1_ratio: 0.5\n",
      "Best cross-validated RMSE: 1.07\n"
     ]
    }
   ],
   "source": [
    "# Video Review with Elastic Net Regression using Primary_Impact_Type as Target Tuning Parameters\n",
    "\n",
    "param_grid = {\n",
    "    'alpha': np.logspace(-3, 1, 10),        \n",
    "    'l1_ratio': [0.1, 0.3, 0.5, 0.7, 0.9]  \n",
    "}\n",
    "\n",
    "elastic_net = ElasticNet(max_iter=10000)\n",
    "\n",
    "grid_search = GridSearchCV(\n",
    "    estimator=elastic_net,\n",
    "    param_grid=param_grid,\n",
    "    scoring='neg_mean_squared_error',\n",
    "    cv=repeated_cv,  \n",
    "    n_jobs=-1        \n",
    ")\n",
    "\n",
    "grid_search.fit(X_train_scaled, y_train)\n",
    "\n",
    "best_params = grid_search.best_params_\n",
    "best_rmse = np.sqrt(-grid_search.best_score_)\n",
    "\n",
    "print(f\"Best alpha: {best_params['alpha']}\")\n",
    "print(f\"Best l1_ratio: {best_params['l1_ratio']}\")\n",
    "print(f\"Best cross-validated RMSE: {best_rmse:.2f}\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Elastic Net on Video Review Dataset: 1.07\n",
      "Standard Deviation CV RMSE on Video Review Dataset: 0.11\n"
     ]
    }
   ],
   "source": [
    "# Video Review with Elastic Net Regression using Primary_Impact_Type as Target\n",
    "\n",
    "elastic_net = ElasticNet(alpha=1.2915496650148828, l1_ratio=0.5, max_iter=10000)\n",
    "\n",
    "neg_mse_scores = cross_val_score(\n",
    "    elastic_net,\n",
    "    X_train_scaled,\n",
    "    y_train,\n",
    "    cv=repeated_cv,\n",
    "    scoring='neg_mean_squared_error'\n",
    ")\n",
    "\n",
    "mse_scores = -neg_mse_scores\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Elastic Net on Video Review Dataset: {mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE on Video Review Dataset: {std_rmse:,.2f}')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_injuryrecord = pd.read_csv(\"InjuryRecord.csv\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Object columns before encoding:\n",
      "Index(['GameID', 'PlayKey', 'BodyPart', 'Surface'], dtype='object')\n"
     ]
    }
   ],
   "source": [
    "label_encoder = LabelEncoder()\n",
    "\n",
    "print(\"Object columns before encoding:\")\n",
    "print(df_injuryrecord.select_dtypes(include=['object']).columns)\n",
    "\n",
    "for col in df_injuryrecord.select_dtypes(include=['object']).columns:\n",
    "    df_injuryrecord[col] = label_encoder.fit_transform(df_injuryrecord[col].astype(str))\n",
    "\n",
    "\n",
    "target_column = 'Surface'  \n",
    "X_injury = df_injuryrecord.drop(columns=[target_column])\n",
    "y_injury = df_injuryrecord[target_column]\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(X_injury, y_injury, test_size=0.2, random_state=42)\n",
    "\n",
    "scaler = StandardScaler()\n",
    "X_train_scaled = scaler.fit_transform(X_train)\n",
    "X_test_scaled = scaler.transform(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Lasso Regression on Injury Record Dataset: 0.51\n",
      "Standard Deviation CV RMSE for Lasso Regression on Injury Record Dataset: 0.01\n"
     ]
    }
   ],
   "source": [
    "# Injury Record with Lasso Regression using Surface Type as Target\n",
    "\n",
    "lasso = Lasso(alpha=1.0, max_iter=10000)\n",
    "\n",
    "neg_mse_scores = cross_val_score(lasso, X_train_scaled, y_train, cv=repeated_cv, scoring='neg_mean_squared_error')\n",
    "mse_scores = -neg_mse_scores\n",
    "\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Lasso Regression on Injury Record Dataset: {mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE for Lasso Regression on Injury Record Dataset: {std_rmse:,.2f}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Ridge Regression on Injury Record dataset: 0.54\n",
      "Standard Deviation CV RMSE for Ridge Regression Injury Record dataset: 0.04\n"
     ]
    }
   ],
   "source": [
    "# Injury Record with Ridge Regression using Surface Type as Target\n",
    "\n",
    "ridge = Ridge()\n",
    "\n",
    "neg_mse_scores = cross_val_score(ridge, X_train_scaled, y_train, cv=repeated_cv, scoring='neg_mean_squared_error')\n",
    "mse_scores = -neg_mse_scores\n",
    "\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Ridge Regression on Injury Record dataset: {mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE for Ridge Regression Injury Record dataset: {std_rmse:,.2f}')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best alpha: 0.1668100537200059\n",
      "Best l1_ratio: 0.9\n",
      "Best cross-validated RMSE: 0.51\n"
     ]
    }
   ],
   "source": [
    "# Injury Record with Elastic Net Regression using Surface Type as Target Tuning Parameters\n",
    "\n",
    "param_grid = {\n",
    "    'alpha': np.logspace(-3, 1, 10),        \n",
    "    'l1_ratio': [0.1, 0.3, 0.5, 0.7, 0.9]  \n",
    "}\n",
    "\n",
    "elastic_net = ElasticNet(max_iter=10000)\n",
    "\n",
    "grid_search = GridSearchCV(\n",
    "    estimator=elastic_net,\n",
    "    param_grid=param_grid,\n",
    "    scoring='neg_mean_squared_error',\n",
    "    cv=repeated_cv,  \n",
    "    n_jobs=-1        \n",
    ")\n",
    "\n",
    "grid_search.fit(X_train_scaled, y_train)\n",
    "\n",
    "best_params = grid_search.best_params_\n",
    "best_rmse = np.sqrt(-grid_search.best_score_)\n",
    "\n",
    "print(f\"Best alpha: {best_params['alpha']}\")\n",
    "print(f\"Best l1_ratio: {best_params['l1_ratio']}\")\n",
    "print(f\"Best cross-validated RMSE: {best_rmse:.2f}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Elastic Net on Injury Record Dataset: 0.51\n",
      "Standard Deviation CV RMSE on Injury Record Dataset: 0.01\n"
     ]
    }
   ],
   "source": [
    "# Injury Record with Elastic Net Regression using Surface Type as Target\n",
    "\n",
    "elastic_net = ElasticNet(alpha=0.1668100537200059, l1_ratio=0.9, max_iter=10000)\n",
    "\n",
    "neg_mse_scores = cross_val_score(\n",
    "    elastic_net,\n",
    "    X_train_scaled,\n",
    "    y_train,\n",
    "    cv=repeated_cv,\n",
    "    scoring='neg_mean_squared_error'\n",
    ")\n",
    "\n",
    "mse_scores = -neg_mse_scores\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Elastic Net on Injury Record Dataset: {mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE on Injury Record Dataset: {std_rmse:,.2f}')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Object columns before encoding:\n",
      "Index(['GameID', 'PlayKey', 'RosterPosition', 'StadiumType', 'FieldType',\n",
      "       'Weather', 'PlayType', 'Position', 'PositionGroup'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "df_playlist = pd.read_csv(\"PlayList.csv\")\n",
    "\n",
    "label_encoder = LabelEncoder()\n",
    "\n",
    "print(\"Object columns before encoding:\")\n",
    "print(df_playlist.select_dtypes(include=['object']).columns)\n",
    "\n",
    "for col in df_playlist.select_dtypes(include=['object']).columns:\n",
    "    df_playlist[col] = label_encoder.fit_transform(df_playlist[col].astype(str))\n",
    "\n",
    "\n",
    "target_column = 'PlayType'  \n",
    "X_playlist = df_playlist.drop(columns=[target_column])\n",
    "y_playlist = df_playlist[target_column]\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split(X_playlist, y_playlist, test_size=0.2, random_state=42)\n",
    "\n",
    "scaler = StandardScaler()\n",
    "X_train_scaled = scaler.fit_transform(X_train)\n",
    "X_test_scaled = scaler.transform(X_test)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 125,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Lasso Regression on PlayList Dataset: 2.35\n",
      "Standard Deviation CV RMSE for Lasso Regression on PlayList Dataset: 0.01\n"
     ]
    }
   ],
   "source": [
    "# Playlist with Lasso Regression using Play Type as Target\n",
    "\n",
    "lasso = Lasso(alpha=1.0, max_iter=10000)\n",
    "\n",
    "neg_mse_scores = cross_val_score(lasso, X_train_scaled, y_train, cv=repeated_cv, scoring='neg_mean_squared_error')\n",
    "mse_scores = -neg_mse_scores\n",
    "\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Lasso Regression on PlayList Dataset: {mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE for Lasso Regression on PlayList Dataset: {std_rmse:,.2f}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Ridge Regression on Injury Record dataset: 2.35\n",
      "Standard Deviation CV RMSE for Ridge Regression Injury Record dataset: 0.01\n"
     ]
    }
   ],
   "source": [
    "# Playlist with Ridge Regression using Play Type as Target\n",
    "ridge = Ridge()\n",
    "\n",
    "neg_mse_scores = cross_val_score(ridge, X_train_scaled, y_train, cv=repeated_cv, scoring='neg_mean_squared_error')\n",
    "mse_scores = -neg_mse_scores\n",
    "\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Ridge Regression on PlayList dataset: {mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE for Ridge Regression PlayList dataset: {std_rmse:,.2f}')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best alpha: 0.001\n",
      "Best l1_ratio: 0.1\n",
      "Best cross-validated RMSE: 2.35\n"
     ]
    }
   ],
   "source": [
    "# Playlist with Elastic Net Regression using Play Type as Target Tuning Parameters\n",
    "param_grid = {\n",
    "    'alpha': np.logspace(-3, 1, 10),        \n",
    "    'l1_ratio': [0.1, 0.3, 0.5, 0.7, 0.9]  \n",
    "}\n",
    "\n",
    "elastic_net = ElasticNet(max_iter=10000)\n",
    "\n",
    "grid_search = GridSearchCV(\n",
    "    estimator=elastic_net,\n",
    "    param_grid=param_grid,\n",
    "    scoring='neg_mean_squared_error',\n",
    "    cv=repeated_cv,  \n",
    "    n_jobs=-1        \n",
    ")\n",
    "\n",
    "grid_search.fit(X_train_scaled, y_train)\n",
    "\n",
    "best_params = grid_search.best_params_\n",
    "best_rmse = np.sqrt(-grid_search.best_score_)\n",
    "\n",
    "print(f\"Best alpha: {best_params['alpha']}\")\n",
    "print(f\"Best l1_ratio: {best_params['l1_ratio']}\")\n",
    "print(f\"Best cross-validated RMSE: {best_rmse:.2f}\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 128,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean CV RMSE for Elastic Net on Injury Record Dataset: 2.35\n",
      "Standard Deviation CV RMSE on Injury Record Dataset: 0.01\n"
     ]
    }
   ],
   "source": [
    "# Playlist with Elastic Net Regression using Play Type as Target\n",
    "\n",
    "elastic_net = ElasticNet(alpha=0.001, l1_ratio=0.1, max_iter=10000)\n",
    "\n",
    "neg_mse_scores = cross_val_score(\n",
    "    elastic_net,\n",
    "    X_train_scaled,\n",
    "    y_train,\n",
    "    cv=repeated_cv,\n",
    "    scoring='neg_mean_squared_error'\n",
    ")\n",
    "\n",
    "mse_scores = -neg_mse_scores\n",
    "rmse_scores = np.sqrt(mse_scores)\n",
    "\n",
    "mean_rmse = np.mean(rmse_scores)\n",
    "std_rmse = np.std(rmse_scores)\n",
    "\n",
    "print(f'Mean CV RMSE for Elastic Net on Injury Record Dataset: {mean_rmse:,.2f}')\n",
    "print(f'Standard Deviation CV RMSE on Injury Record Dataset: {std_rmse:,.2f}')\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
